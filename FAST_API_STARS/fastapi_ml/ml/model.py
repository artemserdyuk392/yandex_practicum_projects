# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oRFJbqdK-yehmPtVRGD4w3KT3vA61Cu_
"""

from dataclasses import dataclass
from pathlib import Path

import yaml
from transformers import pipeline

#config_path = Path(__file__).parent / "config.yaml"
#with open(config_path, "r") as file:
#    config = yaml.load(file, Loader=yaml.FullLoader)


@dataclass
class TempPrediction:
    temp:float

def load_model():
#
    import random
    import numpy as np
    import pandas as pd
    import torch
    import torch.nn as nn
    from math import ceil
    import matplotlib.pyplot as plt
    import seaborn as sns
    import plotly.express as px
    from sklearn.preprocessing import OneHotEncoder
    from sklearn.preprocessing import StandardScaler
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error
    random.seed(42)
    np.random.seed(42)
    torch.manual_seed(42)
    torch.use_deterministic_algorithms(True)

    from IPython.display import display, HTML
    import ipywidgets as widgets
    import time
    import seaborn as sns
    import os
    cwd = os.path.dirname(__file__)
    data = pd.read_csv(cwd+'/data_neuro.csv')
    data_index = data['Unnamed: 0']
    data = data.drop('Unnamed: 0', axis = 1)
    data.columns = ['temp', 'luminosity', 'radius', 'abs_magnitude', 'star_type', 'star_color']
    data.star_color = data.star_color.str.lower()
    data.star_color = data.star_color.str.replace('-','')
    data.star_color = data.star_color.str.replace(' ','')
    data.star_color = data.star_color.str.replace('yellowish','yellow')
    data.star_color = data.star_color.str.replace('whitish','white')
    data.star_color = data.star_color.str.replace('whiteyellow','white')
    log_cols = ['temp', 'luminosity', 'radius']
    for c in log_cols:
        data[c+'_log'] = np.log10(data[c])
    data = data[data['temp'] < 32000]
    for x in ['whiteyellow', 'orangered', 'paleyelloworange' ,'paleyelloworange' ,'yellowwhite',
             'white','orange' ,'yellow']:
        data.star_color = data.star_color.str.replace(x,'other')
    data.star_color = data.star_color.str.replace('blueother','bluewhite')
    data['index'] = data_index
    data_train, data_test = train_test_split(data,test_size = 0.25, random_state = 1) # , random_state = 1
    data_test, data_valid = train_test_split(data_test,test_size = 0.5, random_state = 1)
    y_valid = data_valid['temp']
    x_valid = data_valid.drop(['temp', 'index'], axis = 1)
    y_test = data_test[['temp' ,'index']]
    y_test_index = data_test.index
    y_test = y_test['temp']
    y_train = data_train['temp']
    x_train = data_train.drop(['temp', 'index'], axis = 1)
    x_test = data_test.drop(['temp', 'index'], axis = 1)
    from sklearn.preprocessing import OneHotEncoder
    import pandas as pd
    for x in ['star_color','star_type']:
        encoder = OneHotEncoder(sparse_output=False, drop='first')
        encoder.fit(x_train[x].values.reshape(-1, 1))

        x_train_enc = encoder.transform(x_train[[x]].values.reshape(-1, 1))
        x_test_enc = encoder.transform(x_test[[x]].values.reshape(-1, 1))
        x_valid_enc = encoder.transform(x_valid[[x]].values.reshape(-1, 1))

        columns = [f'star_colour_{col}' for col in encoder.categories_[0][1:]]
        x_train_enc = pd.DataFrame(x_train_enc, columns=columns, index=x_train.index)
        x_test_enc = pd.DataFrame(x_test_enc, columns=columns, index=x_test.index)
        x_valid_enc = pd.DataFrame(x_valid_enc, columns=columns, index=x_valid.index)

        x_train = pd.concat([x_train, x_train_enc], axis=1)
        x_test = pd.concat([x_test, x_test_enc], axis=1)
        x_valid = pd.concat([x_valid, x_valid_enc], axis=1)

        x_train = x_train.drop(x, axis=1)
        x_test = x_test.drop(x, axis=1)
        x_valid = x_valid.drop(x, axis=1)
    x_train = x_train.drop(['temp_log','radius_log','luminosity_log'], axis = 1)
    x_test = x_test.drop(['temp_log','radius_log','luminosity_log'], axis = 1)
    x_valid = x_valid.drop(['temp_log','radius_log','luminosity_log'], axis = 1)
    scaler = StandardScaler()
    numeric = ['luminosity', 'radius', 'abs_magnitude',]
    scaler.fit(x_train[numeric])
    x_train[numeric] = scaler.transform(x_train[numeric])
    x_test[numeric] = scaler.transform(x_test[numeric])
    x_valid[numeric] = scaler.transform(x_valid[numeric])
    x_train = torch.FloatTensor(x_train.values)
    x_test = torch.FloatTensor(x_test.values)
    x_valid = torch.FloatTensor(x_valid.values)
    y_train = torch.FloatTensor(y_train.values).view(-1, 1)
    y_test = torch.FloatTensor(y_test.values).view(-1, 1)
    y_valid = torch.FloatTensor(y_valid.values).view(-1, 1)
    x_train_and_test = torch.cat((x_train, x_test), 0)
    y_train_and_test = torch.cat((y_train, y_test), 0)
    progress_bar = widgets.FloatProgress(
        value=0.0,
        min=0.0,
        max=1.0,
        description='Progress:',
        style={'bar_color': 'lightblue'}
    )
    display(progress_bar)
    n_in_neurons = 11
    n_hidden_neurons_1 = 10000
    n_hidden_neurons_2 = 1000
    n_hidden_neurons_3 = 100
    n_hidden_neurons_4 = 10
    n_out_neurons = 1

    net = nn.Sequential(
        nn.Linear(n_in_neurons, n_hidden_neurons_1),
        nn.ReLU(),
        nn.Linear(n_hidden_neurons_1, n_hidden_neurons_2),
        nn.ReLU(),
        nn.Linear(n_hidden_neurons_2, n_hidden_neurons_3),
        nn.ReLU(),
        nn.Linear(n_hidden_neurons_3, n_hidden_neurons_4),
        nn.ReLU(),
        nn.Linear(n_hidden_neurons_4, n_out_neurons)
    )

    optimizer = torch.optim.Adam(net.parameters())
    loss = nn.MSELoss()

    num_epochs = 570
    for epoch in range(num_epochs):
        optimizer.zero_grad()
        preds = net.forward(x_train_and_test)
        loss_value = loss(preds, y_train_and_test)
        loss_value.backward()
        optimizer.step()
        if epoch % 10 == 0 or epoch == num_epochs - 1:
            net.eval()
            valid_preds = net.forward(x_valid)
            valid_preds_np = valid_preds.detach().numpy()
            RMSE_valid = np.sqrt(mean_squared_error(y_valid.numpy(), valid_preds_np))
            if epoch % 50 == 0:
                print('epoch:', epoch, 'RMSE_val:',RMSE_valid)
        time.sleep(0.0)
        progress_bar.value = (epoch + 1) / num_epochs
    valid_rmse = RMSE_valid
    progress_bar.close()
#
    def model(luminosity:float, radius:float, abs_magnitude:float,  star_type:int, star_color:str) -> TempPrediction:
        x_train = pd.read_csv(cwd+'/data_train.csv')
        x_features = {
        'luminosity': [luminosity],
        'radius': [radius],
        'abs_magnitude': [abs_magnitude],
        'star_color': [star_color],
        'star_type':[star_type],
        }
        x_features = pd.DataFrame(x_features)
        if x_features.star_color.iloc[0] not in ['red','blue','bluewhite','other']:
            x_features.star_color = x_features.star_color.str.replace(x,'other')
        x_train = x_train.drop(['temp_log','radius_log','luminosity_log'], axis = 1)
        for x in ['star_color','star_type']:
            encoder = OneHotEncoder(sparse_output=False, drop='first')
            encoder.fit(x_train[x].values.reshape(-1, 1))
            x_features_enc = encoder.transform(x_features[[x]].values.reshape(-1, 1))
            columns = [f'star_colour_{col}' for col in encoder.categories_[0][1:]]
            x_features_enc = pd.DataFrame(x_features_enc, columns=columns, index=x_features.index)
            x_features = pd.concat([x_features, x_features_enc], axis=1)
            x_features = x_features.drop(x, axis=1)
        scaler = StandardScaler()
        numeric = ['luminosity', 'radius', 'abs_magnitude']
        scaler.fit(x_features[numeric])
        x_features[numeric] = scaler.transform(x_features[numeric])
        x_features = torch.FloatTensor(x_features.values)
        net.eval()
        preds = net.forward(x_features)
        temp = preds.detach().numpy()
        return float(temp[0][0])
    return model

